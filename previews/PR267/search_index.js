var documenterSearchIndex = {"docs":
[{"location":"vis/#Visualization","page":"Visualization","title":"Visualization","text":"SparseMatrixColorings provides some internal utilities for visualization of matrix colorings via the un-exported function SparseMatrixColorings.show_colors.\n\nwarning: Warning\nThis function makes use of the JuliaImages ecosystem. Using it requires loading at least Colors.jl. We recommend loading the full Images.jl package for convenience, which includes Colors.jl.\n\nusing ColorSchemes\nusing Images\nusing SparseArrays\nusing SparseMatrixColorings\nusing SparseMatrixColorings: show_colors\nusing StableRNGs","category":"section"},{"location":"vis/#Basic-usage","page":"Visualization","title":"Basic usage","text":"To obtain a visualization, simply call show_colors on a coloring result. It returns a tuple of outputs, corresponding to the matrix and its compression(s):\n\nS = sparse([\n    0 0 1 1 0 1\n    1 0 0 0 1 0\n    0 1 0 0 1 0\n    0 1 1 0 0 0\n]);\n\nproblem = ColoringProblem(; structure=:nonsymmetric, partition=:column)\nalgo = GreedyColoringAlgorithm(; decompression=:direct)\nresult = coloring(S, problem, algo)\n\nA_img, B_img = show_colors(result; scale=3)\n\nThe colors on the original matrix look like this:\n\nA_img\n\nAnd its column compression looks like that:\n\nB_img\n\ntip: Terminal support\nLoading ImageInTerminal.jl will allow you to show the output of show_colors within your terminal. If you use VSCode's Julia REPL, the matrix will be displayed in the plot tab.","category":"section"},{"location":"vis/#Customization","page":"Visualization","title":"Customization","text":"The visualization can be customized via keyword arguments. The size of the matrix entries is defined by scale, while gaps between them are dictated by pad. We recommend using the ColorSchemes.jl catalogue to customize the colorscheme. Finally, a background color can be passed via the background keyword argument. To obtain transparent backgrounds, use the RGBA type.\n\nWe demonstrate this on a bidirectional coloring.\n\nS = sparse([\n    1 1 1 1 1 1 1 1 1\n    1 0 0 0 0 0 0 0 1\n    1 0 0 0 0 0 0 0 1\n    1 0 0 0 0 0 0 0 1\n    1 0 0 0 0 0 0 0 1\n    1 1 1 1 1 1 1 1 1\n])\n\nproblem_bi = ColoringProblem(; structure=:nonsymmetric, partition=:bidirectional)\nalgo_bi = GreedyColoringAlgorithm(RandomOrder(StableRNG(0)); postprocessing=true, decompression=:direct)\nresult_bi = coloring(S, problem_bi, algo_bi)\n\nArc_img, Ar_img, Ac_img, Br_img, Bc_img = show_colors(\n    result_bi;\n    colorscheme=ColorSchemes.progress,\n    background_color=RGB(1, 1, 1),  # white\n    scale=10,\n    border=1,\n    pad=2\n)\n\nIn the bidirectional case, columns and rows can both get colors:\n\nAr_img\n\nAc_img\n\nTogether, this yields:\n\nArc_img\n\nAnd there are two associated compression results, one by row and one by column:\n\nBr_img\n\nBc_img","category":"section"},{"location":"vis/#Working-with-large-matrices","page":"Visualization","title":"Working with large matrices","text":"Let's demonstrate visualization of a larger random matrix:\n\nS = sprand(50, 50, 0.1) # sample sparse matrix\n\nproblem = ColoringProblem(; structure=:nonsymmetric, partition=:column)\nalgo = GreedyColoringAlgorithm(; decompression=:direct)\nresult = coloring(S, problem, algo)\nshow_colors(result; scale=5, pad=1)[1]\n\nInstead of the default distinguishable_colors from Colors.jl, one can subsample a continuous colorscheme from ColorSchemes.jl:\n\nncolors = maximum(column_colors(result)) # for partition=:column\ncolorscheme = get(ColorSchemes.rainbow, range(0.0, 1.0, length=ncolors))\nshow_colors(result; colorscheme=colorscheme, scale=5, pad=1)[1]","category":"section"},{"location":"vis/#Saving-images","page":"Visualization","title":"Saving images","text":"The resulting image can be saved to a variety of formats, like PNG. The scale and pad parameters determine the number of pixels, and thus the size of the file.\n\nA_img, _ = show_colors(result, scale=5)\nsave(\"coloring.png\", A_img)\n\nRefer to the JuliaImages documentation on saving for more information.","category":"section"},{"location":"api/#API-reference","page":"API reference","title":"API reference","text":"The docstrings on this page define the public API of the package.","category":"section"},{"location":"api/#Main-function","page":"API reference","title":"Main function","text":"","category":"section"},{"location":"api/#Coloring-algorithms","page":"API reference","title":"Coloring algorithms","text":"","category":"section"},{"location":"api/#Result-analysis","page":"API reference","title":"Result analysis","text":"","category":"section"},{"location":"api/#Decompression","page":"API reference","title":"Decompression","text":"","category":"section"},{"location":"api/#Orders","page":"API reference","title":"Orders","text":"","category":"section"},{"location":"api/#SparseMatrixColorings.SparseMatrixColorings","page":"API reference","title":"SparseMatrixColorings.SparseMatrixColorings","text":"SparseMatrixColorings\n\nSparseMatrixColorings.jl\n\n(Image: Build Status) (Image: Stable Documentation) (Image: Dev Documentation) (Image: Coverage) (Image: Code Style: Blue) (Image: arXiv) (Image: DOI)\n\nColoring algorithms for sparse Jacobian and Hessian matrices.\n\nGetting started\n\nTo install this package, run the following in a Julia Pkg REPL:\n\npkg> add SparseMatrixColorings\n\nBackground\n\nThe algorithms implemented in this package are described in the following preprint:\n\nRevisiting Sparse Matrix Coloring and Bicoloring, Montoison et al. (2025)\n\nand inspired by previous works:\n\nWhat Color Is Your Jacobian? Graph Coloring for Computing Derivatives, Gebremedhin et al. (2005)\nNew Acyclic and Star Coloring Algorithms with Application to Computing Hessians, Gebremedhin et al. (2007)\nEfficient Computation of Sparse Hessians Using Coloring and Automatic Differentiation, Gebremedhin et al. (2009)\nColPack: Software for graph coloring and related problems in scientific computing, Gebremedhin et al. (2013)\n\nSome parts of the articles (like definitions) are thus copied verbatim in the documentation.\n\nAlternatives\n\nColPack.jl: a Julia interface to the C++ library ColPack\nSparseDiffTools.jl: contains Julia implementations of some coloring algorithms\n\nCiting\n\nPlease cite this software using the provided CITATION.cff file or the .bib entry below:\n\n@unpublished{montoison2025revisitingsparsematrixcoloring,\n      title={Revisiting Sparse Matrix Coloring and Bicoloring}, \n      author={Alexis Montoison and Guillaume Dalle and Assefaw Gebremedhin},\n      year={2025},\n      eprint={2505.07308},\n      archivePrefix={arXiv},\n      primaryClass={math.NA},\n      url={https://arxiv.org/abs/2505.07308}, \n}\n\nThe link https://zenodo.org/doi/10.5281/zenodo.11314275 resolves to the latest version on Zenodo.\n\nExports\n\nAbstractColoringResult\nColoringProblem\nConstantColoringAlgorithm\nDynamicDegreeBasedOrder\nDynamicLargestFirst\nGreedyColoringAlgorithm\nIncidenceDegree\nLargestFirst\nNaturalOrder\nOptimalColoringAlgorithm\nPerfectEliminationOrder\nRandomOrder\nSmallestLast\ncoloring\ncolumn_colors\ncolumn_groups\ncompress\ndecompress\ndecompress!\ndecompress_single_color!\nfast_coloring\nncolors\nrow_colors\nrow_groups\nsparsity_pattern\n\n\n\n\n\n","category":"module"},{"location":"api/#SparseMatrixColorings.coloring","page":"API reference","title":"SparseMatrixColorings.coloring","text":"coloring(\n    S::AbstractMatrix,\n    problem::ColoringProblem,\n    algo::GreedyColoringAlgorithm;\n    [decompression_eltype=Float64, symmetric_pattern=false]\n)\n\nSolve a ColoringProblem on the matrix S with a GreedyColoringAlgorithm and return an AbstractColoringResult.\n\nThe result can be used to compress and decompress a matrix A with the same sparsity pattern as S. If eltype(A) == decompression_eltype, decompression might be faster.\n\nFor a :nonsymmetric problem (and only then), setting symmetric_pattern=true indicates that the pattern of nonzeros is symmetric. This condition is weaker than the symmetry of actual values, so it can happen for some Jacobians. Specifying it allows faster construction of the bipartite graph.\n\nExample\n\njulia> using SparseMatrixColorings, SparseArrays\n\njulia> S = sparse([\n           0 0 1 1 0 1\n           1 0 0 0 1 0\n           0 1 0 0 1 0\n           0 1 1 0 0 0\n       ]);\n\njulia> problem = ColoringProblem(; structure=:nonsymmetric, partition=:column);\n\njulia> algo = GreedyColoringAlgorithm(; decompression=:direct);\n\njulia> result = coloring(S, problem, algo);\n\njulia> column_colors(result)\n6-element Vector{Int64}:\n 1\n 1\n 2\n 1\n 2\n 3\n\njulia> collect.(column_groups(result))\n3-element Vector{Vector{Int64}}:\n [1, 2, 4]\n [3, 5]\n [6]\n\nSee also\n\nColoringProblem\nGreedyColoringAlgorithm\nAbstractColoringResult\ncompress\ndecompress\n\n\n\n\n\n","category":"function"},{"location":"api/#SparseMatrixColorings.fast_coloring","page":"API reference","title":"SparseMatrixColorings.fast_coloring","text":"fast_coloring(\n    S::AbstractMatrix,\n    problem::ColoringProblem,\n    algo::GreedyColoringAlgorithm;\n    [symmetric_pattern=false]\n)\n\nSolve a ColoringProblem on the matrix S with a GreedyColoringAlgorithm and return\n\na single color vector for :column and :row problems\na tuple of color vectors for :bidirectional problems\n\nThis function is very similar to coloring, but it skips the computation of an AbstractColoringResult to speed things up.\n\nSee also\n\ncoloring\n\n\n\n\n\n","category":"function"},{"location":"api/#SparseMatrixColorings.ColoringProblem","page":"API reference","title":"SparseMatrixColorings.ColoringProblem","text":"ColoringProblem{structure,partition}\n\nSelector type for the coloring problem to solve, enabling multiple dispatch.\n\nIt is passed as an argument to the main function coloring.\n\nConstructors\n\nColoringProblem{structure,partition}()\nColoringProblem(; structure=:nonsymmetric, partition=:column)\n\nstructure::Symbol: either :nonsymmetric or :symmetric\npartition::Symbol: either :column, :row or :bidirectional\n\nwarning: Warning\nThe second constructor (based on keyword arguments) is type-unstable.\n\nLink to automatic differentiation\n\nMatrix coloring is often used in automatic differentiation, and here is the translation guide:\n\nmatrix mode structure partition implemented\nJacobian forward :nonsymmetric :column yes\nJacobian reverse :nonsymmetric :row yes\nJacobian mixed :nonsymmetric :bidirectional yes\nHessian - :symmetric :column yes\nHessian - :symmetric :row no\n\n\n\n\n\n","category":"type"},{"location":"api/#SparseMatrixColorings.GreedyColoringAlgorithm","page":"API reference","title":"SparseMatrixColorings.GreedyColoringAlgorithm","text":"GreedyColoringAlgorithm{decompression} <: ADTypes.AbstractColoringAlgorithm\n\nGreedy coloring algorithm for sparse matrices which colors columns or rows one after the other, following a configurable order.\n\nIt is passed as an argument to the main function coloring.\n\nConstructors\n\nGreedyColoringAlgorithm{decompression}(order=NaturalOrder(); postprocessing=false, postprocessing_minimizes=:all_colors)\nGreedyColoringAlgorithm(order=NaturalOrder(); postprocessing=false, postprocessing_minimizes=:all_colors, decompression=:direct)\n\norder::Union{AbstractOrder,Tuple}: the order in which the columns or rows are colored, which can impact the number of colors. Can also be a tuple of different orders to try out, from which the best order (the one with the lowest total number of colors) will be used.\npostprocessing::Bool: whether or not the coloring will be refined by assigning the neutral color 0 to some vertices. This option does not affect row or column colorings.\npostprocessing_minimizes::Symbol: which number of distinct colors is heuristically minimized by postprocessing, either :all_colors, :row_colors or :column_colors. This option only affects bidirectional colorings.\ndecompression::Symbol: either :direct or :substitution. Usually :substitution leads to fewer colors, at the cost of a more expensive coloring (and decompression). When :substitution is not applicable, it falls back on :direct decompression.\n\nwarning: Warning\nThe second constructor (based on keyword arguments) is type-unstable.\n\nADTypes coloring interface\n\nGreedyColoringAlgorithm is a subtype of ADTypes.AbstractColoringAlgorithm, which means the following methods are also applicable:\n\nADTypes.column_coloring\nADTypes.row_coloring\nADTypes.symmetric_coloring\n\nSee their respective docstrings for details.\n\nSee also\n\nAbstractOrder\ndecompress\n\n\n\n\n\n","category":"type"},{"location":"api/#SparseMatrixColorings.ConstantColoringAlgorithm","page":"API reference","title":"SparseMatrixColorings.ConstantColoringAlgorithm","text":"ConstantColoringAlgorithm{partition}  <: ADTypes.AbstractColoringAlgorithm\n\nColoring algorithm which always returns the same precomputed vector of colors. Useful when the optimal coloring of a matrix can be determined a priori due to its specific structure (e.g. banded).\n\nIt is passed as an argument to the main function coloring, but will only work if the associated problem has a :column or :row partition.\n\nConstructors\n\nConstantColoringAlgorithm{partition}(matrix_template, color)\nConstantColoringAlgorithm{partition,structure}(matrix_template, color)\nConstantColoringAlgorithm(\n    matrix_template, color;\n    structure=:nonsymmetric, partition=:column\n)\n\npartition::Symbol: either :row or :column.\nstructure::Symbol: either :nonsymmetric or :symmetric.\nmatrix_template::AbstractMatrix: matrix for which the vector of colors was precomputed (the algorithm will only accept matrices of the exact same size).\ncolor::Vector{<:Integer}: vector of integer colors, one for each row or column (depending on partition).\n\nwarning: Warning\nThe constructor based on keyword arguments is type-unstable if these arguments are not compile-time constants.\n\nWe do not necessarily verify consistency between the matrix template and the vector of colors, this is the responsibility of the user.\n\nExample\n\njulia> using SparseMatrixColorings, LinearAlgebra\n\njulia> matrix_template = Diagonal(ones(Bool, 5))\n5×5 Diagonal{Bool, Vector{Bool}}:\n 1  ⋅  ⋅  ⋅  ⋅\n ⋅  1  ⋅  ⋅  ⋅\n ⋅  ⋅  1  ⋅  ⋅\n ⋅  ⋅  ⋅  1  ⋅\n ⋅  ⋅  ⋅  ⋅  1\n\njulia> color = ones(Int, 5)  # coloring a Diagonal is trivial\n5-element Vector{Int64}:\n 1\n 1\n 1\n 1\n 1\n\njulia> problem = ColoringProblem(; structure=:nonsymmetric, partition=:column);\n\njulia> algo = ConstantColoringAlgorithm(matrix_template, color; partition=:column);\n\njulia> result = coloring(similar(matrix_template), problem, algo);\n\njulia> column_colors(result)\n5-element Vector{Int64}:\n 1\n 1\n 1\n 1\n 1\n\nADTypes coloring interface\n\nConstantColoringAlgorithm is a subtype of ADTypes.AbstractColoringAlgorithm, which means the following methods are also applicable (although they will error if the kind of coloring demanded not consistent):\n\nADTypes.column_coloring\nADTypes.row_coloring\nADTypes.symmetric_coloring\n\n\n\n\n\n","category":"type"},{"location":"api/#SparseMatrixColorings.OptimalColoringAlgorithm","page":"API reference","title":"SparseMatrixColorings.OptimalColoringAlgorithm","text":"OptimalColoringAlgorithm\n\nColoring algorithm that relies on mathematical programming with JuMP to find an optimal coloring.\n\nwarning: Warning\nThis algorithm is only available when JuMP is loaded. If you encounter a method error, run import JuMP in your REPL and try again. It only works for nonsymmetric, unidirectional colorings problems.\n\ndanger: Danger\nThe coloring problem is NP-hard, so it is unreasonable to expect an optimal solution in reasonable time for large instances.\n\nConstructor\n\nOptimalColoringAlgorithm(optimizer; silent::Bool=true, assert_solved::Bool=true)\n\nThe optimizer argument can be any JuMP-compatible optimizer. However, the problem formulation is best suited to CP-SAT optimizers like MiniZinc. You can use optimizer_with_attributes to set solver-specific parameters.\n\nKeyword arguments\n\nsilent: whether to suppress solver output\nassert_solved: whether to check that the solver found an optimal solution (as opposed to running out of time for example)\n\n\n\n\n\n","category":"type"},{"location":"api/#SparseMatrixColorings.AbstractColoringResult","page":"API reference","title":"SparseMatrixColorings.AbstractColoringResult","text":"AbstractColoringResult{structure,partition,decompression}\n\nAbstract type for the result of a coloring algorithm.\n\nIt is the supertype of the object returned by the main function coloring.\n\nType parameters\n\nCombination between the type parameters of ColoringProblem and GreedyColoringAlgorithm:\n\nstructure::Symbol: either :nonsymmetric or :symmetric\npartition::Symbol: either :column, :row or :bidirectional\ndecompression::Symbol: either :direct or :substitution\n\nApplicable methods\n\ncolumn_colors and column_groups (for a :column or :bidirectional partition) \nrow_colors and row_groups (for a :row or :bidirectional partition)\nsparsity_pattern\ncompress, decompress, decompress!, decompress_single_color!\n\nwarning: Warning\nUnlike the methods above, the concrete subtypes of AbstractColoringResult are not part of the public API and may change without notice.\n\n\n\n\n\n","category":"type"},{"location":"api/#SparseMatrixColorings.column_colors","page":"API reference","title":"SparseMatrixColorings.column_colors","text":"column_colors(result::AbstractColoringResult)\n\nReturn a vector color of integer colors, one for each column of the colored matrix.\n\n\n\n\n\n","category":"function"},{"location":"api/#SparseMatrixColorings.row_colors","page":"API reference","title":"SparseMatrixColorings.row_colors","text":"row_colors(result::AbstractColoringResult)\n\nReturn a vector color of integer colors, one for each row of the colored matrix.\n\n\n\n\n\n","category":"function"},{"location":"api/#SparseMatrixColorings.ncolors","page":"API reference","title":"SparseMatrixColorings.ncolors","text":"ncolors(result::AbstractColoringResult)\n\nReturn the number of different non-zero colors used to color the matrix.\n\nFor bidirectional partitions, this number is the sum of the number of non-zero row colors and the number of non-zero column colors.\n\n\n\n\n\n","category":"function"},{"location":"api/#SparseMatrixColorings.column_groups","page":"API reference","title":"SparseMatrixColorings.column_groups","text":"column_groups(result::AbstractColoringResult)\n\nReturn a vector group such that for every non-zero color c, group[c] contains the indices of all columns that are colored with c.\n\n\n\n\n\n","category":"function"},{"location":"api/#SparseMatrixColorings.row_groups","page":"API reference","title":"SparseMatrixColorings.row_groups","text":"row_groups(result::AbstractColoringResult)\n\nReturn a vector group such that for every non-zero color c, group[c] contains the indices of all rows that are colored with c.\n\n\n\n\n\n","category":"function"},{"location":"api/#SparseMatrixColorings.sparsity_pattern","page":"API reference","title":"SparseMatrixColorings.sparsity_pattern","text":"sparsity_pattern(result::AbstractColoringResult)\n\nReturn the matrix that was initially passed to coloring, without any modifications.\n\nnote: Note\nThis matrix is not necessarily a SparseMatrixCSC, nor does it necessarily have Bool entries.\n\n\n\n\n\n","category":"function"},{"location":"api/#SparseMatrixColorings.compress","page":"API reference","title":"SparseMatrixColorings.compress","text":"compress(A, result::AbstractColoringResult)\n\nCompress A given a coloring result of the sparsity pattern of A.\n\nIf result comes from a :column (resp. :row) partition, the output is a single matrix B compressed by column (resp. by row).\nIf result comes from a :bidirectional partition, the output is a tuple of matrices (Br, Bc), where Br is compressed by row and Bc by column.\n\nCompression means summing either the columns or the rows of A which share the same color. It is undone by calling decompress or decompress!.\n\nExample\n\njulia> using SparseMatrixColorings, SparseArrays\n\njulia> A = sparse([\n           0 0 4 6 0 9\n           1 0 0 0 7 0\n           0 2 0 0 8 0\n           0 3 5 0 0 0\n       ]);\n\njulia> result = coloring(A, ColoringProblem(), GreedyColoringAlgorithm());\n\njulia> collect.(column_groups(result))\n3-element Vector{Vector{Int64}}:\n [1, 2, 4]\n [3, 5]\n [6]\n\njulia> B = compress(A, result)\n4×3 Matrix{Int64}:\n 6  4  9\n 1  7  0\n 2  8  0\n 3  5  0\n\nSee also\n\nColoringProblem\nAbstractColoringResult\n\n\n\n\n\n","category":"function"},{"location":"api/#SparseMatrixColorings.decompress","page":"API reference","title":"SparseMatrixColorings.decompress","text":"decompress(B::AbstractMatrix, result::AbstractColoringResult{_,:column/:row})\ndecompress(Br::AbstractMatrix, Bc::AbstractMatrix, result::AbstractColoringResult{_,:bidirectional})\n\nDecompress B (or the tuple (Br,Bc)) into a new matrix A, given a coloring result of the sparsity pattern of A. The in-place alternative is decompress!.\n\nCompression means summing either the columns or the rows of A which share the same color. It is done by calling compress.\n\nwarning: Warning\nFor some coloring variants, the result object is mutated during decompression.\n\nExample\n\njulia> using SparseMatrixColorings, SparseArrays\n\njulia> A = sparse([\n           0 0 4 6 0 9\n           1 0 0 0 7 0\n           0 2 0 0 8 0\n           0 3 5 0 0 0\n       ]);\n\njulia> result = coloring(A, ColoringProblem(), GreedyColoringAlgorithm());\n\njulia> collect.(column_groups(result))\n3-element Vector{Vector{Int64}}:\n [1, 2, 4]\n [3, 5]\n [6]\n\njulia> B = compress(A, result)\n4×3 Matrix{Int64}:\n 6  4  9\n 1  7  0\n 2  8  0\n 3  5  0\n\njulia> decompress(B, result)\n4×6 SparseMatrixCSC{Int64, Int64} with 9 stored entries:\n ⋅  ⋅  4  6  ⋅  9\n 1  ⋅  ⋅  ⋅  7  ⋅\n ⋅  2  ⋅  ⋅  8  ⋅\n ⋅  3  5  ⋅  ⋅  ⋅\n\njulia> decompress(B, result) == A\ntrue\n\nSee also\n\nColoringProblem\nAbstractColoringResult\n\n\n\n\n\n","category":"function"},{"location":"api/#SparseMatrixColorings.decompress!","page":"API reference","title":"SparseMatrixColorings.decompress!","text":"decompress!(\n    A::AbstractMatrix, B::AbstractMatrix,\n    result::AbstractColoringResult{_,:column/:row}, [uplo=:F]\n)\n\ndecompress!(\n    A::AbstractMatrix, Br::AbstractMatrix, Bc::AbstractMatrix\n    result::AbstractColoringResult{_,:bidirectional}\n)\n\nDecompress B (or the tuple (Br,Bc)) in-place into A, given a coloring result of the sparsity pattern of A. The out-of-place alternative is decompress.\n\nnote: Note\nIn-place decompression is faster when A isa SparseMatrixCSC.\n\nCompression means summing either the columns or the rows of A which share the same color. It is done by calling compress.\n\nFor :symmetric coloring results (and for those only), an optional positional argument uplo in (:U, :L, :F) can be passed to specify which part of the matrix A should be updated: the Upper triangle, the Lower triangle, or the Full matrix. When A isa SparseMatrixCSC, using the uplo argument requires a target matrix which only stores the relevant triangle(s).\n\nwarning: Warning\nFor some coloring variants, the result object is mutated during decompression.\n\nExample\n\njulia> using SparseMatrixColorings, SparseArrays\n\njulia> A = sparse([\n           0 0 4 6 0 9\n           1 0 0 0 7 0\n           0 2 0 0 8 0\n           0 3 5 0 0 0\n       ]);\n\njulia> result = coloring(A, ColoringProblem(), GreedyColoringAlgorithm());\n\njulia> collect.(column_groups(result))\n3-element Vector{Vector{Int64}}:\n [1, 2, 4]\n [3, 5]\n [6]\n\njulia> B = compress(A, result)\n4×3 Matrix{Int64}:\n 6  4  9\n 1  7  0\n 2  8  0\n 3  5  0\n\njulia> A2 = similar(A);\n\njulia> decompress!(A2, B, result)\n4×6 SparseMatrixCSC{Int64, Int64} with 9 stored entries:\n ⋅  ⋅  4  6  ⋅  9\n 1  ⋅  ⋅  ⋅  7  ⋅\n ⋅  2  ⋅  ⋅  8  ⋅\n ⋅  3  5  ⋅  ⋅  ⋅\n\njulia> A2 == A\ntrue\n\nSee also\n\nColoringProblem\nAbstractColoringResult\n\n\n\n\n\n","category":"function"},{"location":"api/#SparseMatrixColorings.decompress_single_color!","page":"API reference","title":"SparseMatrixColorings.decompress_single_color!","text":"decompress_single_color!(\n    A::AbstractMatrix, b::AbstractVector, c::Integer,\n    result::AbstractColoringResult, [uplo=:F]\n)\n\nDecompress the vector b corresponding to color c in-place into A, given a :direct coloring result of the sparsity pattern of A (it will not work with a :substitution coloring).\n\nIf result comes from a :nonsymmetric structure with :column partition, this will update the columns of A that share color c (whose sum makes up b).\nIf result comes from a :nonsymmetric structure with :row partition, this will update the rows of A that share color c (whose sum makes up b).\nIf result comes from a :symmetric structure with :column partition, this will update the coefficients of A whose value is deduced from color c.\n\nwarning: Warning\nThis function will only update some coefficients of A, without resetting the rest to zero.\n\nFor :symmetric coloring results (and for those only), an optional positional argument uplo in (:U, :L, :F) can be passed to specify which part of the matrix A should be updated: the Upper triangle, the Lower triangle, or the Full matrix. When A isa SparseMatrixCSC, using the uplo argument requires a target matrix which only stores the relevant triangle(s).\n\nwarning: Warning\nFor some coloring variants, the result object is mutated during decompression.\n\nExample\n\njulia> using SparseMatrixColorings, SparseArrays\n\njulia> A = sparse([\n           0 0 4 6 0 9\n           1 0 0 0 7 0\n           0 2 0 0 8 0\n           0 3 5 0 0 0\n       ]);\n\njulia> result = coloring(A, ColoringProblem(), GreedyColoringAlgorithm());\n\njulia> collect.(column_groups(result))\n3-element Vector{Vector{Int64}}:\n [1, 2, 4]\n [3, 5]\n [6]\n\njulia> B = compress(A, result)\n4×3 Matrix{Int64}:\n 6  4  9\n 1  7  0\n 2  8  0\n 3  5  0\n\njulia> A2 = similar(A); A2 .= 0;\n\njulia> decompress_single_color!(A2, B[:, 2], 2, result)\n4×6 SparseMatrixCSC{Int64, Int64} with 9 stored entries:\n ⋅  ⋅  4  0  ⋅  0\n 0  ⋅  ⋅  ⋅  7  ⋅\n ⋅  0  ⋅  ⋅  8  ⋅\n ⋅  0  5  ⋅  ⋅  ⋅\n\njulia> A2[:, [3, 5]] == A[:, [3, 5]]\ntrue\n\nSee also\n\nColoringProblem\nAbstractColoringResult\ndecompress!\n\n\n\n\n\n","category":"function"},{"location":"api/#SparseMatrixColorings.AbstractOrder","page":"API reference","title":"SparseMatrixColorings.AbstractOrder","text":"AbstractOrder\n\nAbstract supertype for the vertex order used inside GreedyColoringAlgorithm.\n\nIn this algorithm, the rows and columns of a matrix form a graph, and the vertices are colored one after the other in a greedy fashion. Depending on how the vertices are ordered, the number of colors necessary may vary.\n\nOptions\n\nNaturalOrder\nRandomOrder\nLargestFirst\nIncidenceDegree (experimental)\nSmallestLast (experimental)\nDynamicLargestFirst (experimental)\nPerfectEliminationOrder\n\n\n\n\n\n","category":"type"},{"location":"api/#SparseMatrixColorings.NaturalOrder","page":"API reference","title":"SparseMatrixColorings.NaturalOrder","text":"NaturalOrder()\n\nInstance of AbstractOrder which sorts vertices using their index in the provided graph.\n\n\n\n\n\n","category":"type"},{"location":"api/#SparseMatrixColorings.RandomOrder","page":"API reference","title":"SparseMatrixColorings.RandomOrder","text":"RandomOrder(rng=default_rng(), seed=nothing)\n\nInstance of AbstractOrder which sorts vertices using a random permutation, generated from rng with a given seed.\n\nIf seed = nothing, the rng will never be re-seeded. Therefore, two consecutive calls to vertices(g, order) will give different results.\nOtherwise, the rng will be re-seeded before each sample. Therefore, two consecutive calls to vertices(g, order) will give the same result.\n\nwarning: Warning\nDo not use a seed with the default_rng(), otherwise you will affect the global state of your program. If you need reproducibility, create a new rng specifically for your RandomOrder. The package StableRNGs.jl offers random number generators whose behavior is stable across Julia versions.\n\n\n\n\n\n","category":"type"},{"location":"api/#SparseMatrixColorings.LargestFirst","page":"API reference","title":"SparseMatrixColorings.LargestFirst","text":"LargestFirst()\n\nInstance of AbstractOrder which sorts vertices using their degree in the provided graph: the largest degree comes first.\n\n\n\n\n\n","category":"type"},{"location":"api/#SparseMatrixColorings.SmallestLast","page":"API reference","title":"SparseMatrixColorings.SmallestLast","text":"SmallestLast(; reproduce_colpack=false)\n\nInstance of AbstractOrder which sorts vertices from highest to lowest using the dynamic back degree.\n\nSee also\n\nDynamicDegreeBasedOrder\n\n\n\n\n\n","category":"function"},{"location":"api/#SparseMatrixColorings.IncidenceDegree","page":"API reference","title":"SparseMatrixColorings.IncidenceDegree","text":"IncidenceDegree(; reproduce_colpack=false)\n\nInstance of AbstractOrder which sorts vertices from lowest to highest using the dynamic back degree.\n\nSee also\n\nDynamicDegreeBasedOrder\n\n\n\n\n\n","category":"function"},{"location":"api/#SparseMatrixColorings.DynamicLargestFirst","page":"API reference","title":"SparseMatrixColorings.DynamicLargestFirst","text":"DynamicLargestFirst(; reproduce_colpack=false)\n\nInstance of AbstractOrder which sorts vertices from lowest to highest using the dynamic forward degree.\n\nSee also\n\nDynamicDegreeBasedOrder\n\n\n\n\n\n","category":"function"},{"location":"api/#SparseMatrixColorings.DynamicDegreeBasedOrder","page":"API reference","title":"SparseMatrixColorings.DynamicDegreeBasedOrder","text":"DynamicDegreeBasedOrder{degtype,direction}(; reproduce_colpack=false)\n\nInstance of AbstractOrder which sorts vertices using a dynamically computed degree.\n\nThis order works by assigning vertices to buckets based on their dynamic degree, and then updating buckets iteratively by transfering vertices between them.\n\nType parameters\n\ndegtype::Symbol: can be :forward (for the forward degree) or :back (for the back degree)\ndirection::Symbol: can be :low2high (if the order is defined from lowest to highest, i.e. 1 to n) or :high2low (if the order is defined from highest to lowest, i.e. n to 1)\n\nConcrete variants\n\nIncidenceDegree\nSmallestLast\nDynamicLargestFirst\n\nSettings\n\nreproduce_colpack::Bool: whether to manage the buckets in the exact same way as the original ColPack implementation.\nWhen reproduce_colpack=true, we always append and remove vertices at the end of a bucket (unilateral).\nWhen reproduce_colpack=false (the default), we can append and remove vertices either at the start or at the end of a bucket (bilateral).\n\nAllowing modifications on both sides of a bucket enables storage optimization, with a single fixed-size vector for all buckets instead of one dynamically-sized vector per bucket. As a result, the default setting reproduce_colpack=false is slightly more memory-efficient.\n\nReferences\n\nColPack: Software for graph coloring and related problems in scientific computing, Gebremedhin et al. (2013), Section 5\n\n\n\n\n\n","category":"type"},{"location":"api/#SparseMatrixColorings.PerfectEliminationOrder","page":"API reference","title":"SparseMatrixColorings.PerfectEliminationOrder","text":"PerfectEliminationOrder(elimination_algorithm=CliqueTrees.MCS())\n\nInstance of AbstractOrder which computes a perfect elimination ordering when the underlying graph is chordal. For non-chordal graphs, it computes a suboptimal ordering.\n\nThe elimination_algorithm must be an instance of CliqueTrees.EliminationAlgorithm.\n\nwarning: Warning\nThis order can only be applied for symmetric or bidirectional coloring problems. Furthermore, its theoretical guarantees only hold for decompression by substitution.\n\ndanger: Danger\nThis order is implemented as a package extension and requires loading CliqueTrees.jl.\n\nReferences\n\nSimple Linear-Time Algorithms to Test Chordality of Graphs, Test Acyclicity of Hypergraphs, and Selectively Reduce Acyclic Hypergraphs, Tarjan and Yannakakis (1984)\n\n\n\n\n\n","category":"type"},{"location":"dev/#Internals","page":"Internals","title":"Internals","text":"The docstrings on this page describe internals, they are not part of the public API.","category":"section"},{"location":"dev/#Graph-storage","page":"Internals","title":"Graph storage","text":"","category":"section"},{"location":"dev/#Low-level-coloring","page":"Internals","title":"Low-level coloring","text":"","category":"section"},{"location":"dev/#Concrete-coloring-results","page":"Internals","title":"Concrete coloring results","text":"","category":"section"},{"location":"dev/#Testing","page":"Internals","title":"Testing","text":"","category":"section"},{"location":"dev/#Matrix-handling","page":"Internals","title":"Matrix handling","text":"","category":"section"},{"location":"dev/#Visualization","page":"Internals","title":"Visualization","text":"","category":"section"},{"location":"dev/#Examples","page":"Internals","title":"Examples","text":"","category":"section"},{"location":"dev/#SparseMatrixColorings.SparsityPatternCSC","page":"Internals","title":"SparseMatrixColorings.SparsityPatternCSC","text":"SparsityPatternCSC{Ti<:Integer}\n\nStore a sparse matrix (in CSC) without its values, keeping only the pattern of nonzeros.\n\nFields\n\nCopied from SparseMatrixCSC:\n\nm::Int: number of rows\nn::Int: number of columns\ncolptr::Vector{Ti}: column j is in colptr[j]:(colptr[j+1]-1)\nrowval::Vector{Ti}: row indices of stored values\n\n\n\n\n\n","category":"type"},{"location":"dev/#SparseMatrixColorings.AdjacencyGraph","page":"Internals","title":"SparseMatrixColorings.AdjacencyGraph","text":"AdjacencyGraph{T,augmented_graph}\n\nUndirected graph without self-loops representing the nonzeros of a symmetric matrix (typically a Hessian matrix).\n\nThe adjacency graph of a symmetric matrix A ∈ ℝ^{n × n} is G(A) = (V, E) where\n\nV = 1:n is the set of rows or columns i/j\n(i, j) ∈ E whenever A[i, j] ≠ 0 and i ≠ j\n\nConstructors\n\nAdjacencyGraph(A::SparseMatrixCSC; augmented_graph::Bool=false)\n\nFields\n\nS::SparsityPatternCSC{T}: Underlying sparsity pattern, which represents an augmented graph whenever augmented_graph is true. Here, \"augmented graph\" means the sparsity pattern of the augmented matrix H = [0 Jᵀ; J 0].\nedge_to_index::Vector{T}: A vector mapping each nonzero of S to a unique edge index (ignoring diagonal and accounting for symmetry, so that (i, j) and (j, i) get the same index)\n\nReferences\n\nWhat Color Is Your Jacobian? SparsityPatternCSC Coloring for Computing Derivatives, Gebremedhin et al. (2005)\n\n\n\n\n\n","category":"type"},{"location":"dev/#SparseMatrixColorings.BipartiteGraph","page":"Internals","title":"SparseMatrixColorings.BipartiteGraph","text":"BipartiteGraph{T}\n\nUndirected bipartite graph representing the nonzeros of a non-symmetric matrix (typically a Jacobian matrix).\n\nThe bipartite graph of a matrix A ∈ ℝ^{m × n} is Gb(A) = (V₁, V₂, E) where\n\nV₁ = 1:m is the set of rows i\nV₂ = 1:n is the set of columns j\n(i, j) ∈ E whenever A[i, j] ≠ 0\n\nA BipartiteGraph has two sets of vertices, one for the rows of A (which we call side 1) and one for the columns (which we call side 2).\n\nConstructors\n\nBipartiteGraph(A::SparseMatrixCSC; symmetric_pattern::Bool=false)\n\nWhen symmetric_pattern is true, this construction is more efficient.\n\nFields\n\nS1::SparsityPatternCSC{T}: maps vertices on side 1 to their neighbors\nS2::SparsityPatternCSC{T}: maps vertices on side 2 to their neighbors\n\nReferences\n\nWhat Color Is Your Jacobian? SparsityPatternCSC Coloring for Computing Derivatives, Gebremedhin et al. (2005)\n\n\n\n\n\n","category":"type"},{"location":"dev/#SparseMatrixColorings.vertices","page":"Internals","title":"SparseMatrixColorings.vertices","text":"vertices(bg::BipartiteGraph, Val(side))\n\nReturn the list of vertices of bg from the specified side as a range 1:n.\n\n\n\n\n\n","category":"function"},{"location":"dev/#SparseMatrixColorings.neighbors","page":"Internals","title":"SparseMatrixColorings.neighbors","text":"neighbors(bg::BipartiteGraph, Val(side), v::Integer)\n\nReturn the neighbors of v (a vertex from the specified side, 1 or 2), in the graph bg.\n\n\n\n\n\n","category":"function"},{"location":"dev/#Base.transpose","page":"Internals","title":"Base.transpose","text":"transpose(S::SparsityPatternCSC)\n\nReturn a SparsityPatternCSC corresponding to the transpose of S.\n\n\n\n\n\n","category":"function"},{"location":"dev/#SparseMatrixColorings.bidirectional_pattern","page":"Internals","title":"SparseMatrixColorings.bidirectional_pattern","text":"bidirectional_pattern(A::AbstractMatrix; symmetric_pattern::Bool)\n\nReturn a SparsityPatternCSC corresponding to the matrix [0 Aᵀ; A 0], with a minimum of allocations.\n\n\n\n\n\n","category":"function"},{"location":"dev/#SparseMatrixColorings.partial_distance2_coloring","page":"Internals","title":"SparseMatrixColorings.partial_distance2_coloring","text":"partial_distance2_coloring(\n    bg::BipartiteGraph, ::Val{side}, vertices_in_order::AbstractVector;\n    forced_colors::Union{AbstractVector{<:Integer},Nothing}=nothing\n)\n\nCompute a distance-2 coloring of the given side (1 or 2) in the bipartite graph bg and return a vector of integer colors.\n\nA distance-2 coloring is such that two vertices have different colors if they are at distance at most 2.\n\nThe vertices are colored in a greedy fashion, following the order supplied.\n\nThe optional forced_colors keyword argument is used to enforce predefined vertex colors (e.g. coming from another optimization algorithm) but still run the distance-2 coloring procedure to verify correctness.\n\nSee also\n\nBipartiteGraph\nAbstractOrder\n\nReferences\n\nWhat Color Is Your Jacobian? Graph Coloring for Computing Derivatives, Gebremedhin et al. (2005), Algorithm 3.2\n\n\n\n\n\n","category":"function"},{"location":"dev/#SparseMatrixColorings.star_coloring","page":"Internals","title":"SparseMatrixColorings.star_coloring","text":"star_coloring(\n    g::AdjacencyGraph, vertices_in_order::AbstractVector, postprocessing::Bool;\n    postprocessing_minimizes::Symbol=:all_colors, forced_colors::Union{AbstractVector,Nothing}=nothing\n)\n\nCompute a star coloring of all vertices in the adjacency graph g and return a tuple (color, star_set), where\n\ncolor is the vector of integer colors\nstar_set is a StarSet encoding the set of 2-colored stars\n\nA star coloring is a distance-1 coloring such that every path on 4 vertices uses at least 3 colors.\n\nThe vertices are colored in a greedy fashion, following the order supplied.\n\nIf postprocessing=true, some colors might be replaced with 0 (the \"neutral\" color) as long as they are not needed during decompression.\n\nThe optional forced_colors keyword argument is used to enforce predefined vertex colors (e.g. coming from another optimization algorithm) but still run the star coloring procedure to verify correctness and build auxiliary data structures, useful during decompression.\n\nSee also\n\nAdjacencyGraph\nAbstractOrder\n\nReferences\n\nNew Acyclic and Star Coloring Algorithms with Application to Computing Hessians, Gebremedhin et al. (2007), Algorithm 4.1\n\n\n\n\n\n","category":"function"},{"location":"dev/#SparseMatrixColorings.acyclic_coloring","page":"Internals","title":"SparseMatrixColorings.acyclic_coloring","text":"acyclic_coloring(g::AdjacencyGraph, vertices_in_order::AbstractVector, postprocessing::Bool;\n                 postprocessing_minimizes::Symbol=:all_colors)\n\nCompute an acyclic coloring of all vertices in the adjacency graph g and return a tuple (color, tree_set), where\n\ncolor is the vector of integer colors\ntree_set is a TreeSet encoding the set of 2-colored trees\n\nAn acyclic coloring is a distance-1 coloring with the further restriction that every cycle uses at least 3 colors.\n\nThe vertices are colored in a greedy fashion, following the order supplied.\n\nIf postprocessing=true, some colors might be replaced with 0 (the \"neutral\" color) as long as they are not needed during decompression.\n\nSee also\n\nAdjacencyGraph\nAbstractOrder\n\nReferences\n\nNew Acyclic and Star Coloring Algorithms with Application to Computing Hessians, Gebremedhin et al. (2007), Algorithm 3.1\n\n\n\n\n\n","category":"function"},{"location":"dev/#SparseMatrixColorings.group_by_color","page":"Internals","title":"SparseMatrixColorings.group_by_color","text":"group_by_color(color::AbstractVector{<:Integer})\n\nCreate a color-indexed vector group such that i ∈ group[c] iff color[i] == c for all c > 0.\n\nAssumes the colors are contiguously numbered from 0 to some cmax.\n\n\n\n\n\n","category":"function"},{"location":"dev/#SparseMatrixColorings.Forest","page":"Internals","title":"SparseMatrixColorings.Forest","text":"mutable struct Forest{T<:Integer}\n\nStructure that provides fast union-find operations for constructing a forest during acyclic coloring and bicoloring.\n\nFields\n\nnt::Integer: current number of distinct trees in the forest\nparents::Vector{T} where T<:Integer: vector storing the index of a parent in the tree for each edge, used in union-find operations\nranks::Vector{T} where T<:Integer: vector approximating the depth of each tree to optimize path compression\n\n\n\n\n\n","category":"type"},{"location":"dev/#SparseMatrixColorings.StarSet","page":"Internals","title":"SparseMatrixColorings.StarSet","text":"StarSet\n\nEncode a set of 2-colored stars resulting from the star_coloring algorithm.\n\nFields\n\nstar::Vector: a mapping from edges (pair of vertices) to their star index\nhub::Vector: a mapping from star indices to their hub (undefined hubs for single-edge stars are the negative value of one of the vertices, picked arbitrarily)\n\n\n\n\n\n","category":"type"},{"location":"dev/#SparseMatrixColorings.TreeSet","page":"Internals","title":"SparseMatrixColorings.TreeSet","text":"TreeSet\n\nEncode a set of 2-colored trees resulting from the acyclic_coloring algorithm.\n\nFields\n\nreverse_bfs_orders::Array{Tuple{T, T}, 1} where T\nis_star::Vector{Bool}\ntree_edge_indices::Vector\nnt::Any\n\n\n\n\n\n","category":"type"},{"location":"dev/#SparseMatrixColorings.ColumnColoringResult","page":"Internals","title":"SparseMatrixColorings.ColumnColoringResult","text":"struct ColumnColoringResult{M<:(AbstractMatrix), T<:Integer, G<:SparseMatrixColorings.BipartiteGraph{T<:Integer}, CT<:AbstractArray{T<:Integer, 1}, GT<:(AbstractArray{<:AbstractArray{T<:Integer, 1}, 1}), VT<:AbstractArray{T<:Integer, 1}, A} <: AbstractColoringResult{:nonsymmetric, :column, :direct}\n\nStorage for the result of a column coloring with direct decompression.\n\nFields\n\nA::AbstractMatrix: matrix that was colored\nbg::SparseMatrixColorings.BipartiteGraph: bipartite graph that was used for coloring\ncolor::AbstractVector{T} where T<:Integer: one integer color for each column or row (depending on partition)\ngroup::AbstractVector{<:AbstractVector{T}} where T<:Integer: color groups for columns or rows (depending on partition)\ncompressed_indices::AbstractVector{T} where T<:Integer: flattened indices mapping the compressed matrix B to the uncompressed matrix A when A isa SparseMatrixCSC. They satisfy nonzeros(A)[k] = vec(B)[compressed_indices[k]]\nadditional_info::Any: optional data used for decompressing into specific matrix types\n\nSee also\n\nAbstractColoringResult\n\n\n\n\n\n","category":"type"},{"location":"dev/#SparseMatrixColorings.RowColoringResult","page":"Internals","title":"SparseMatrixColorings.RowColoringResult","text":"struct RowColoringResult{M<:(AbstractMatrix), T<:Integer, G<:SparseMatrixColorings.BipartiteGraph{T<:Integer}, CT<:AbstractArray{T<:Integer, 1}, GT<:(AbstractArray{<:AbstractArray{T<:Integer, 1}, 1}), VT<:AbstractArray{T<:Integer, 1}, A} <: AbstractColoringResult{:nonsymmetric, :row, :direct}\n\nStorage for the result of a row coloring with direct decompression.\n\nFields\n\nSee the docstring of ColumnColoringResult.\n\nA::AbstractMatrix\nbg::SparseMatrixColorings.BipartiteGraph\ncolor::AbstractVector{T} where T<:Integer\ngroup::AbstractVector{<:AbstractVector{T}} where T<:Integer\ncompressed_indices::AbstractVector{T} where T<:Integer\nadditional_info::Any\n\nSee also\n\nAbstractColoringResult\n\n\n\n\n\n","category":"type"},{"location":"dev/#SparseMatrixColorings.StarSetColoringResult","page":"Internals","title":"SparseMatrixColorings.StarSetColoringResult","text":"struct StarSetColoringResult{M<:(AbstractMatrix), T<:Integer, G<:(SparseMatrixColorings.AdjacencyGraph{T<:Integer}), CT<:AbstractArray{T<:Integer, 1}, GT<:(AbstractArray{<:AbstractArray{T<:Integer, 1}, 1}), VT<:AbstractArray{T<:Integer, 1}, A} <: AbstractColoringResult{:symmetric, :column, :direct}\n\nStorage for the result of a symmetric coloring with direct decompression.\n\nFields\n\nSee the docstring of ColumnColoringResult.\n\nA::AbstractMatrix\nag::SparseMatrixColorings.AdjacencyGraph\ncolor::AbstractVector{T} where T<:Integer\ngroup::AbstractVector{<:AbstractVector{T}} where T<:Integer\ncompressed_indices::AbstractVector{T} where T<:Integer\nadditional_info::Any\n\nSee also\n\nAbstractColoringResult\n\n\n\n\n\n","category":"type"},{"location":"dev/#SparseMatrixColorings.TreeSetColoringResult","page":"Internals","title":"SparseMatrixColorings.TreeSetColoringResult","text":"struct TreeSetColoringResult{M<:(AbstractMatrix), T<:Integer, G<:(SparseMatrixColorings.AdjacencyGraph{T<:Integer}), GT<:(AbstractArray{<:AbstractArray{T<:Integer, 1}, 1}), R} <: AbstractColoringResult{:symmetric, :column, :substitution}\n\nStorage for the result of a symmetric coloring with decompression by substitution.\n\nFields\n\nSee the docstring of ColumnColoringResult.\n\nA::AbstractMatrix\nag::SparseMatrixColorings.AdjacencyGraph\ncolor::Vector{T} where T<:Integer\ngroup::AbstractVector{<:AbstractVector{T}} where T<:Integer\nreverse_bfs_orders::Array{Tuple{T, T}, 1} where T<:Integer\ntree_edge_indices::Vector{T} where T<:Integer\nnt::Integer\ndiagonal_indices::Vector{T} where T<:Integer\ndiagonal_nzind::Vector{T} where T<:Integer\nlower_triangle_offsets::Vector{T} where T<:Integer\nupper_triangle_offsets::Vector{T} where T<:Integer\nbuffer::Vector\n\nSee also\n\nAbstractColoringResult\n\n\n\n\n\n","category":"type"},{"location":"dev/#SparseMatrixColorings.LinearSystemColoringResult","page":"Internals","title":"SparseMatrixColorings.LinearSystemColoringResult","text":"struct LinearSystemColoringResult{M<:(AbstractMatrix), T<:Integer, G<:(SparseMatrixColorings.AdjacencyGraph{T<:Integer}), GT<:(AbstractArray{<:AbstractArray{T<:Integer, 1}, 1}), R, F} <: AbstractColoringResult{:symmetric, :column, :substitution}\n\nStorage for the result of a symmetric coloring with any decompression.\n\nFields\n\nSee the docstring of ColumnColoringResult.\n\nA::AbstractMatrix\nag::SparseMatrixColorings.AdjacencyGraph\ncolor::Vector{T} where T<:Integer\ngroup::AbstractVector{<:AbstractVector{T}} where T<:Integer\nstrict_upper_nonzero_inds::Array{Tuple{T, T}, 1} where T<:Integer\nstrict_upper_nonzeros_A::Vector\nM_factorization::Any\n\nSee also\n\nAbstractColoringResult\n\n\n\n\n\n","category":"type"},{"location":"dev/#SparseMatrixColorings.BicoloringResult","page":"Internals","title":"SparseMatrixColorings.BicoloringResult","text":"struct BicoloringResult{M<:(AbstractMatrix), T<:Integer, G<:(SparseMatrixColorings.AdjacencyGraph{T<:Integer}), decompression, GT<:(AbstractArray{<:AbstractArray{T<:Integer, 1}, 1}), SR<:AbstractColoringResult{:symmetric, :column, decompression}, R} <: AbstractColoringResult{:nonsymmetric, :bidirectional, decompression}\n\nStorage for the result of a bidirectional coloring with direct or substitution decompression, based on the symmetric coloring of a 2x2 block matrix.\n\nFields\n\nA::AbstractMatrix: matrix that was colored\nabg::SparseMatrixColorings.AdjacencyGraph: augmented adjacency graph that was used for bicoloring\ncolumn_color::Vector{T} where T<:Integer: one integer color for each column\nrow_color::Vector{T} where T<:Integer: one integer color for each row\ncolumn_group::AbstractVector{<:AbstractVector{T}} where T<:Integer: color groups for columns\nrow_group::AbstractVector{<:AbstractVector{T}} where T<:Integer: color groups for rows\nsymmetric_result::AbstractColoringResult{:symmetric, :column}: result for the coloring of the symmetric 2 x 2 block matrix\nsymmetric_to_column::Vector{T} where T<:Integer: maps symmetric colors to column colors\nsymmetric_to_row::Vector{T} where T<:Integer: maps symmetric colors to row colors\nBr_and_Bc::Matrix: combination of Br and Bc (almost a concatenation up to color remapping)\nlarge_colptr::Vector{T} where T<:Integer: CSC storage of A_and_noAᵀ -colptr`\nlarge_rowval::Vector{T} where T<:Integer: CSC storage of A_and_noAᵀ -rowval`\n\nSee also\n\nAbstractColoringResult\n\n\n\n\n\n","category":"type"},{"location":"dev/#SparseMatrixColorings.remap_colors","page":"Internals","title":"SparseMatrixColorings.remap_colors","text":"remap_colors(color::Vector{<:Integer}, num_sym_colors::Integer, m::Integer, n::Integer)\n\nReturn a tuple (row_color, column_color, symmetric_to_row, symmetric_to_column) such that row_color and column_color are vectors containing the renumbered colors for rows and columns. symmetric_to_row and symmetric_to_column are vectors that map symmetric colors to row and column colors.\n\nFor all vertex indices i between 1 and m we have:\n\nrow_color[i] = symmetric_to_row[color[n+i]]\n\nFor all vertex indices j between 1 and n we have:\n\ncolumn_color[j] = symmetric_to_column[color[j]]\n\n\n\n\n\n","category":"function"},{"location":"dev/#SparseMatrixColorings.directly_recoverable_columns","page":"Internals","title":"SparseMatrixColorings.directly_recoverable_columns","text":"directly_recoverable_columns(\n    A::AbstractMatrix, color::AbstractVector{<:Integer}\n    verbose=false\n)\n\nReturn true if coloring the columns of the symmetric matrix A with the vector color results in a column-compressed representation that preserves every unique value, thus making direct recovery possible.\n\nwarning: Warning\nThis function is not coded with efficiency in mind, it is designed for small-scale tests.\n\nReferences\n\nWhat Color Is Your Jacobian? Graph Coloring for Computing Derivatives, Gebremedhin et al. (2005)\n\n\n\n\n\n","category":"function"},{"location":"dev/#SparseMatrixColorings.symmetrically_orthogonal_columns","page":"Internals","title":"SparseMatrixColorings.symmetrically_orthogonal_columns","text":"symmetrically_orthogonal_columns(\n    A::AbstractMatrix, color::AbstractVector{<:Integer};\n    verbose=false\n)\n\nReturn true if coloring the columns of the symmetric matrix A with the vector color results in a partition that is symmetrically orthogonal, and false otherwise.\n\nA partition of the columns of a symmetric matrix A is symmetrically orthogonal if, for every nonzero element A[i, j], either of the following statements holds:\n\nthe group containing the column A[:, j] has no other column with a nonzero in row i\nthe group containing the column A[:, i] has no other column with a nonzero in row j\n\nwarning: Warning\nThis function is not coded with efficiency in mind, it is designed for small-scale tests.\n\nReferences\n\nWhat Color Is Your Jacobian? Graph Coloring for Computing Derivatives, Gebremedhin et al. (2005)\n\n\n\n\n\n","category":"function"},{"location":"dev/#SparseMatrixColorings.structurally_orthogonal_columns","page":"Internals","title":"SparseMatrixColorings.structurally_orthogonal_columns","text":"structurally_orthogonal_columns(\n    A::AbstractMatrix, color::AbstractVector{<:Integer};\n    verbose=false\n)\n\nReturn true if coloring the columns of the matrix A with the vector color results in a partition that is structurally orthogonal, and false otherwise.\n\nA partition of the columns of a matrix A is structurally orthogonal if, for every nonzero element A[i, j], the group containing column A[:, j] has no other column with a nonzero in row i.\n\nwarning: Warning\nThis function is not coded with efficiency in mind, it is designed for small-scale tests.\n\nReferences\n\nWhat Color Is Your Jacobian? Graph Coloring for Computing Derivatives, Gebremedhin et al. (2005)\n\n\n\n\n\n","category":"function"},{"location":"dev/#SparseMatrixColorings.structurally_biorthogonal","page":"Internals","title":"SparseMatrixColorings.structurally_biorthogonal","text":"structurally_biorthogonal(\n    A::AbstractMatrix, row_color::AbstractVector{<:Integer}, column_color::AbstractVector{<:Integer};\n    verbose=false\n)\n\nReturn true if bicoloring of the matrix A with the vectors row_color and column_color results in a bipartition that is structurally biorthogonal, and false otherwise.\n\nA bipartition of the rows and columns of a matrix A is structurally biorthogonal if, for every nonzero element A[i, j], either of the following statements holds:\n\nthe group containing the column A[:, j] has no other column with a nonzero in row i\nthe group containing the row A[i, :] has no other row with a nonzero in column j\n\nwarning: Warning\nThis function is not coded with efficiency in mind, it is designed for small-scale tests.\n\n\n\n\n\n","category":"function"},{"location":"dev/#SparseMatrixColorings.valid_dynamic_order","page":"Internals","title":"SparseMatrixColorings.valid_dynamic_order","text":"valid_dynamic_order(g::AdjacencyGraph, π::AbstractVector{<:Integer}, order::DynamicDegreeBasedOrder)\nvalid_dynamic_order(bg::AdjacencyGraph, ::Val{side}, π::AbstractVector{<:Integer}, order::DynamicDegreeBasedOrder)\n\nCheck that a permutation π corresponds to a valid application of a DynamicDegreeBasedOrder.\n\nThis is done by checking, for each ordered vertex, that its back- or forward-degree was the smallest or largest among the remaining vertices (the specifics depend on the order parameters).\n\nwarning: Warning\nThis function is not coded with efficiency in mind, it is designed for small-scale tests.\n\n\n\n\n\n","category":"function"},{"location":"dev/#SparseMatrixColorings.respectful_similar","page":"Internals","title":"SparseMatrixColorings.respectful_similar","text":"respectful_similar(A::AbstractMatrix)\nrespectful_similar(A::AbstractMatrix, ::Type{T})\n\nLike Base.similar but returns a transpose or adjoint when A is a transpose or adjoint.\n\n\n\n\n\n","category":"function"},{"location":"dev/#SparseMatrixColorings.matrix_versions","page":"Internals","title":"SparseMatrixColorings.matrix_versions","text":"matrix_versions(A::AbstractMatrix)\n\nReturn various versions of the same matrix:\n\ndense and sparse\ntranspose and adjoint\n\nUsed for internal testing.\n\n\n\n\n\n","category":"function"},{"location":"dev/#SparseMatrixColorings.same_pattern","page":"Internals","title":"SparseMatrixColorings.same_pattern","text":"same_pattern(A, B)\n\nPerform a partial equality check on the sparsity patterns of A and B:\n\nif the return is true, they might have the same sparsity pattern but we're not sure\nif the return is false, they definitely don't have the same sparsity pattern\n\n\n\n\n\n","category":"function"},{"location":"dev/#SparseMatrixColorings.show_colors","page":"Internals","title":"SparseMatrixColorings.show_colors","text":"show_colors(result; kwargs...)\n\nCreate a visualization for an AbstractColoringResult, with the help of the JuliaImages ecosystem.\n\nFor :column or :row colorings, it returns a couple (A_img, B_img).\nFor :bidirectional colorings, it returns a 4-tuple (Ar_img, Ac_img, Br_img, Bc_img).\n\nwarning: Warning\nThis function is implemented in a package extension, using it requires loading Colors.jl.\n\nKeyword arguments\n\ncolorscheme: colors used for non-zero matrix entries. This can be a vector of Colorants or a subsampled scheme from ColorSchemes.jl.\nbackground_color::Colorant: color used for zero matrix entries and pad. Defaults to RGBA(0,0,0,0), a transparent background.\nborder_color::Colorant: color used around matrix entries. Defaults to RGB(0, 0, 0), a black border.\nscale::Int: scale the size of matrix entries to scale × scale pixels. Defaults to 1.\nborder::Int: set border width around matrix entries, in pixles. Defaults to 0. \npad::Int: set padding between matrix entries, in pixels. Defaults to 0. \n\nFor a matrix of size (m, n), the resulting output will be of size (m * (scale + 2border + pad) + pad, n * (scale + 2border + pad) + pad).\n\n\n\n\n\n","category":"function"},{"location":"dev/#SparseMatrixColorings.Example","page":"Internals","title":"SparseMatrixColorings.Example","text":"struct Example{TA<:(AbstractMatrix), TB<:(AbstractMatrix)}\n\nExample coloring problem from one of our reference articles.\n\nUsed for internal testing.\n\nFields\n\nA::AbstractMatrix: decompressed matrix\nB::AbstractMatrix: column-compressed matrix\ncolor::Vector{Int64}: vector of colors\n\n\n\n\n\n","category":"type"},{"location":"dev/#SparseMatrixColorings.what_fig_41","page":"Internals","title":"SparseMatrixColorings.what_fig_41","text":"what_fig_41()\n\nConstruct an Example from Figure 4.1 of \"What color is your Jacobian?\", where the nonzero entries are filled with unique values.\n\n\n\n\n\n","category":"function"},{"location":"dev/#SparseMatrixColorings.what_fig_61","page":"Internals","title":"SparseMatrixColorings.what_fig_61","text":"what_fig_61()\n\nConstruct an Example from Figure 6.1 of \"What color is your Jacobian?\", where the nonzero entries are filled with unique values.\n\n\n\n\n\n","category":"function"},{"location":"dev/#SparseMatrixColorings.efficient_fig_1","page":"Internals","title":"SparseMatrixColorings.efficient_fig_1","text":"efficient_fig_1()\n\nConstruct an Example from Figure 1 of \"Efficient computation of sparse hessians using coloring and AD\", where the nonzero entries are filled with unique values.\n\n\n\n\n\n","category":"function"},{"location":"dev/#SparseMatrixColorings.efficient_fig_4","page":"Internals","title":"SparseMatrixColorings.efficient_fig_4","text":"efficient_fig_4()\n\nConstruct an Example from Figure 4 of \"Efficient computation of sparse hessians using coloring and AD\", where the nonzero entries are filled with unique values.\n\n\n\n\n\n","category":"function"},{"location":"#SparseMatrixColorings.jl","page":"Home","title":"SparseMatrixColorings.jl","text":"(Image: Build Status) (Image: Stable Documentation) (Image: Dev Documentation) (Image: Coverage) (Image: Code Style: Blue) (Image: arXiv) (Image: DOI)\n\nColoring algorithms for sparse Jacobian and Hessian matrices.","category":"section"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"To install this package, run the following in a Julia Pkg REPL:\n\npkg> add SparseMatrixColorings","category":"section"},{"location":"#Background","page":"Home","title":"Background","text":"The algorithms implemented in this package are described in the following preprint:\n\nRevisiting Sparse Matrix Coloring and Bicoloring, Montoison et al. (2025)\n\nand inspired by previous works:\n\nWhat Color Is Your Jacobian? Graph Coloring for Computing Derivatives, Gebremedhin et al. (2005)\nNew Acyclic and Star Coloring Algorithms with Application to Computing Hessians, Gebremedhin et al. (2007)\nEfficient Computation of Sparse Hessians Using Coloring and Automatic Differentiation, Gebremedhin et al. (2009)\nColPack: Software for graph coloring and related problems in scientific computing, Gebremedhin et al. (2013)\n\nSome parts of the articles (like definitions) are thus copied verbatim in the documentation.","category":"section"},{"location":"#Alternatives","page":"Home","title":"Alternatives","text":"ColPack.jl: a Julia interface to the C++ library ColPack\nSparseDiffTools.jl: contains Julia implementations of some coloring algorithms","category":"section"},{"location":"#Citing","page":"Home","title":"Citing","text":"Please cite this software using the provided CITATION.cff file or the .bib entry below:\n\n@unpublished{montoison2025revisitingsparsematrixcoloring,\n      title={Revisiting Sparse Matrix Coloring and Bicoloring}, \n      author={Alexis Montoison and Guillaume Dalle and Assefaw Gebremedhin},\n      year={2025},\n      eprint={2505.07308},\n      archivePrefix={arXiv},\n      primaryClass={math.NA},\n      url={https://arxiv.org/abs/2505.07308}, \n}\n\nThe link https://zenodo.org/doi/10.5281/zenodo.11314275 resolves to the latest version on Zenodo.","category":"section"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"Here we give a brief introduction to the contents of the package, see the API reference for more details.\n\nusing SparseMatrixColorings\nusing LinearAlgebra\nusing SparseArrays\nusing StableRNGs\nusing SparseMatrixColorings: show_colors # hide\nusing Images # hide\n\nscale=15 # hide\npad=3 # hide\nborder=2 # hide\nnothing # hide","category":"section"},{"location":"tutorial/#Coloring-problems-and-algorithms","page":"Tutorial","title":"Coloring problems and algorithms","text":"SparseMatrixColorings.jl is based on the combination of a coloring problem and a coloring algorithm, which will be passed to the coloring function.\n\nThe problem defines what you want to solve. It is always a ColoringProblem, and you can select options such as\n\nthe structure of the matrix (:nonsymmetric or :symmetric)\nthe type of partition you want (:column, :row or :bidirectional).\n\nproblem = ColoringProblem()\n\nThe algorithm defines how you want to solve it. It can be either a GreedyColoringAlgorithm or a ConstantColoringAlgorithm. For GreedyColoringAlgorithm, you can select options such as\n\nthe order in which vertices are processed (a subtype of AbstractOrder , or a tuple of such objects)\nthe type of decompression you want (:direct or :substitution)\n\nalgo = GreedyColoringAlgorithm()","category":"section"},{"location":"tutorial/#Coloring-results","page":"Tutorial","title":"Coloring results","text":"The coloring function takes a matrix, a problem and an algorithm, to return a result subtyping AbstractColoringResult.\n\nS = sparse([\n    0 0 1 1 0 1\n    1 0 0 0 1 0\n    0 1 0 0 1 0\n    0 1 1 0 0 0\n])\n\nresult = coloring(S, problem, algo)\n\nThe detailed type and fields of that result are not part of the public API. To access its contents, you can use the following getters:\n\nsparsity_pattern for the matrix initially provided to coloring\nncolors for the total number of distinct colors\nrow_colors, column_colors for vectors of integer colors (depending on the partition)\nrow_groups, column_groups for vector of row or column indices grouped by color (depending on the partition)\n\nHere, we have a column coloring, so we can try the following:\n\ncolumn_colors(result)\n\ncolumn_groups(result)\n\nncolors(result)","category":"section"},{"location":"tutorial/#Compression-and-decompression","page":"Tutorial","title":"Compression and decompression","text":"The functions compress and decompress efficiently store and retrieve compressed representations of sparse matrices, using the coloring result as a starting point.\n\nCompression sums all columns or rows with the same color:\n\nM = sparse([\n    0 0 4 6 0 9\n    1 0 0 0 7 0\n    0 2 0 0 8 0\n    0 3 5 0 0 0\n])\n\nB = compress(M, result)\n\nDecompression recovers the original matrix from its compressed version:\n\nC = decompress(B, result)\n\nThe functions decompress! and decompress_single_color! are in-place variants of decompress.\n\nD = [\n    10 14 18\n    11 15 0\n    12 16 0\n    13 17 0\n]\n\ndecompress!(C, D, result)\n\nnonzeros(C) .= -1\ndecompress_single_color!(C, D[:, 2], 2, result)","category":"section"},{"location":"tutorial/#Unidirectional-variants","page":"Tutorial","title":"Unidirectional variants","text":"We now illustrate the variants of colorings available, on the following matrix:\n\nS = sparse(Symmetric(sprand(StableRNG(0), Bool, 10, 10, 0.4)))\n\nWe start with unidirectional colorings, where only rows or columns are colored and the matrix is not assumed to be symmetric.","category":"section"},{"location":"tutorial/#Column-coloring","page":"Tutorial","title":"Column coloring","text":"problem = ColoringProblem(; structure=:nonsymmetric, partition=:column)\nalgo = GreedyColoringAlgorithm(; decompression=:direct)\nresult = coloring(S, problem, algo)\nnothing # hide\n\nncolors(result), column_colors(result)\n\nHere is the colored matrix\n\nA_img, B_img = show_colors(result; scale, pad, border) # hide\nA_img # hide\n\nand its columnwise compression\n\nB_img # hide","category":"section"},{"location":"tutorial/#Row-coloring","page":"Tutorial","title":"Row coloring","text":"problem = ColoringProblem(; structure=:nonsymmetric, partition=:row)\nalgo = GreedyColoringAlgorithm(; decompression=:direct)\nresult = coloring(S, problem, algo)\nnothing # hide\n\nncolors(result), row_colors(result)\n\nHere is the colored matrix\n\nA_img, B_img = show_colors(result; scale, pad, border) # hide\nA_img # hide\n\nand its rowwise compression\n\nB_img # hide","category":"section"},{"location":"tutorial/#Symmetric-variants","page":"Tutorial","title":"Symmetric variants","text":"We continue with unidirectional symmetric colorings, where coloring rows is equivalent to coloring columns. Symmetry is leveraged to possibly reduce the number of necessary colors.","category":"section"},{"location":"tutorial/#Star-coloring","page":"Tutorial","title":"Star coloring","text":"Star coloring is the algorithm used for symmetric matrices with direct decompression.\n\nproblem = ColoringProblem(; structure=:symmetric, partition=:column)\nalgo = GreedyColoringAlgorithm(; decompression=:direct)\nresult = coloring(S, problem, algo)\nnothing # hide\n\nncolors(result), column_colors(result)\n\nHere is the colored matrix\n\nA_img, B_img = show_colors(result; scale, pad, border) # hide\nA_img # hide\n\nand its columnwise compression\n\nB_img # hide","category":"section"},{"location":"tutorial/#Acyclic-coloring","page":"Tutorial","title":"Acyclic coloring","text":"Acyclic coloring is the algorithm used for symmetric matrices with decompression by substitution.\n\nproblem = ColoringProblem(; structure=:symmetric, partition=:column)\nalgo = GreedyColoringAlgorithm(; decompression=:substitution)\nresult = coloring(S, problem, algo)\nnothing # hide\n\nncolors(result), column_colors(result)\n\nHere is the colored matrix\n\nA_img, B_img = show_colors(result; scale, pad, border) # hide\nA_img # hide\n\nand its columnwise compression\n\nB_img # hide","category":"section"},{"location":"tutorial/#Bidirectional-variants","page":"Tutorial","title":"Bidirectional variants","text":"We finish with bidirectional colorings, where both rows and columns are colored and the matrix is not assumed to be symmetric.\n\nBicoloring is most relevant for matrices with dense rows and columns, which is why we consider the following test case:\n\nS_bi = copy(S)\nS_bi[:, 1] .= true\nS_bi[1, :] .= true\nS_bi\n\nWith our implementations, bidirectional coloring works better using a RandomOrder.","category":"section"},{"location":"tutorial/#Star-bicoloring","page":"Tutorial","title":"Star bicoloring","text":"problem = ColoringProblem(; structure=:nonsymmetric, partition=:bidirectional)\nalgo = GreedyColoringAlgorithm(RandomOrder(StableRNG(0), 0); decompression=:direct)\nresult = coloring(S_bi, problem, algo)\nnothing # hide\n\nncolors(result), column_colors(result)\n\nHere is the colored matrix\n\nArc_img, _, _, Br_img, Bc_img = show_colors(result; scale, pad, border) # hide\nArc_img # hide\n\nits columnwise compression\n\nBc_img # hide\n\nand rowwise compression\n\nBr_img # hide\n\nBoth are necessary to reconstruct the original.","category":"section"},{"location":"tutorial/#Acyclic-bicoloring","page":"Tutorial","title":"Acyclic bicoloring","text":"problem = ColoringProblem(; structure=:nonsymmetric, partition=:bidirectional)\nalgo = GreedyColoringAlgorithm(RandomOrder(StableRNG(0), 0); decompression=:substitution)\nresult = coloring(S_bi, problem, algo)\nnothing # hide\n\nncolors(result), column_colors(result)\n\nHere is the colored matrix\n\nArc_img, _, _, Br_img, Bc_img = show_colors(result; scale=20, pad, border) # hide\nArc_img # hide\n\nits columnwise compression\n\nBc_img # hide\n\nand rowwise compression\n\nBr_img # hide\n\nBoth are necessary to reconstruct the original.","category":"section"}]
}
